{
	"BIT": {
		"scope": "rust",
		"prefix": "@bit",
		"body": [
			"@monoid$0",
			"struct BIT<M>",
			"where",
			"\tM: Monoid,",
			"{",
			"\tnodes: Vec<M::Val>,",
			"}",
			"impl<M> BIT<M>",
			"where",
			"\tM: Monoid,",
			"{",
			"\tfn new(n: usize) -> Self {",
			"\t\tSelf { nodes: vec![M::id(); n] }",
			"\t}",
			"\tfn add(&mut self, i: usize, x: M::Val) {",
			"\t\tlet mut i = i + 1;",
			"\t\twhile i <= self.nodes.len() {",
			"\t\t\tself.nodes[i - 1] = M::op(&self.nodes[i - 1], &x);",
			"\t\t\ti += i & i.wrapping_neg();",
			"\t\t}",
			"\t}",
			"\tfn sum(&self, i: usize) -> M::Val {",
			"\t\tlet mut i = i + 1;",
			"\t\tlet mut ans = M::id();",
			"\t\twhile i > 0 {",
			"\t\t\tans = M::op(&ans, &self.nodes[i - 1]);",
			"\t\t\ti -= i & i.wrapping_neg();",
			"\t\t}",
			"\t\tans",
			"\t}",
			"}",
		],
		"description": "BIT",
	},
	"Directions": {
		"scope": "rust",
		"prefix": "@dir",
		"body": [
			"const D4: [(isize, isize); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];",
		],
		"description": "Directions",
	},
	"Factorial": {
		"scope": "rust",
		"prefix": "@fact",
		"body": [
			"let mut fact = vec![1; N + 1];",
			"for i in 0..N {",
			"\tfact[i + 1] = fact[i] * (i + 1) % MOD;",
			"}",
			"let mut inv = vec![1; N + 1];",
			"inv[N] = powmod(fact[N], MOD - 2, MOD);",
			"for i in (0..N).rev() {",
			"\tinv[i] = inv[i + 1] * (i + 1) % MOD;",
			"}",
			"",
			"fn nCk(fact: &[usize], inv: &[usize], n: usize, k: usize, m: usize) -> usize {",
			"\tif",
			"\t/*k < 0 ||*/",
			"\tk > n {",
			"\t\t0",
			"\t} else {",
			"\t\tfact[n] * inv[k] % m * inv[n - k] % m",
			"\t}",
			"}",
		],
		"description": "Factorial",
	},
	"Integer Log 2": {
		"scope": "rust",
		"prefix": "@ilog2",
		"body": [
			"/// `ilog2_floor(0)` is `0`.",
			"fn ilog2_floor(n: usize) -> usize {",
			"\tif n == 0 {",
			"\t\t0",
			"\t} else {",
			"\t\tstd::mem::size_of::<usize>() * 8 - 1 - n.leading_zeros() as usize",
			"\t}",
			"}",
		],
		"description": "Integer Log 2",
	},
	"Lowest Common Ancestor": {
		"scope": "rust",
		"prefix": "@lca",
		"body": [
			"@ilog2$0",
			"struct LCA {",
			"\tparents: Vec<Vec<NodeIndex<usize>>>,",
			"\tdepths: Vec<usize>,",
			"}",
			"impl LCA {",
			"\tfn new(G: &UnGraph<(), (), usize>, root: NodeIndex<usize>) -> Self {",
			"\t\tlet mut parents = vec![vec![]; G.node_count()];",
			"\t\tlet mut depths = vec![0; G.node_count()];",
			"\t\tdepth_first_search(&G, Some(root), |ev| {",
			"\t\t\tif let DfsEvent::TreeEdge(pi, i) = ev {",
			"\t\t\t\tparents[i.index()].push(pi);",
			"\t\t\t\tdepths[i.index()] = depths[pi.index()] + 1;",
			"\t\t\t}",
			"\t\t});",
			"\t\tfor b in 0..ilog2_floor(G.node_count()) {",
			"\t\t\tfor i in 0..G.node_count() {",
			"\t\t\t\tif let Some(j) = parents[i.index()].get(b) {",
			"\t\t\t\t\tif let Some(&k) = parents[j.index()].get(b) {",
			"\t\t\t\t\t\tparents[i].push(k);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tSelf { parents, depths }",
			"\t}",
			"\tfn lca(&self, i: NodeIndex<usize>, j: NodeIndex<usize>) -> NodeIndex<usize> {",
			"\t\tlet (mut i, mut j) = (i, j);",
			"\t\tif self.depths[i.index()] > self.depths[j.index()] {",
			"\t\t\tstd::mem::swap(&mut i, &mut j);",
			"\t\t}",
			"\t\tlet d = self.depths[j.index()] - self.depths[i.index()];",
			"\t\tfor b in 0..=ilog2_floor(d) {",
			"\t\t\tif d >> b & 1 == 1 {",
			"\t\t\t\tj = self.parents[j.index()][b];",
			"\t\t\t}",
			"\t\t}",
			"\t\tif i == j {",
			"\t\t\treturn i;",
			"\t\t}",
			"\t\tfor b in (0..=ilog2_floor(self.parents.len())).rev() {",
			"\t\t\tif let Some(&pi) = self.parents[i.index()].get(b) {",
			"\t\t\t\tif let Some(&pj) = self.parents[j.index()].get(b) {",
			"\t\t\t\t\tif pi != pj {",
			"\t\t\t\t\t\ti = pi;",
			"\t\t\t\t\t\tj = pj;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tself.parents[i.index()][0]",
			"\t}",
			"}",
		],
		"description": "Lowest Common Ancestor",
	},
	"Monoid": {
		"scope": "rust",
		"prefix": "@monoid",
		"body": [
			"trait Monoid {",
			"\ttype Val: Clone + Eq;",
			"\tfn op(a: &Self::Val, b: &Self::Val) -> Self::Val;",
			"\tfn id() -> Self::Val;",
			"}",
			"struct PlusMonoid<N>",
			"where",
			"\tN: Copy + Eq + Num,",
			"{",
			"\t_phantom: std::marker::PhantomData<N>,",
			"}",
			"impl<N> Monoid for PlusMonoid<N>",
			"where",
			"\tN: Copy + Eq + Num,",
			"{",
			"\ttype Val = N;",
			"\tfn op(a: &Self::Val, b: &Self::Val) -> Self::Val {",
			"\t\t*a + *b",
			"\t}",
			"\tfn id() -> Self::Val {",
			"\t\tN::zero()",
			"\t}",
			"}",
		],
		"description": "Monoid",
	},
	"Partition Point": {
		"scope": "rust",
		"prefix": "@part",
		"body": [
			"trait PartitionPoint {",
			"\ttype Item;",
			"\tfn partition_point<F>(&self, f: F) -> usize",
			"\twhere",
			"\t\tF: Fn(&Self::Item) -> bool;",
			"}",
			"impl<T> PartitionPoint for [T] {",
			"\ttype Item = T;",
			"\tfn partition_point<F>(&self, f: F) -> usize",
			"\twhere",
			"\t\tF: Fn(&Self::Item) -> bool,",
			"\t{",
			"\t\tlet mut left_is_ok = 0;",
			"\t\tlet mut right_is_ng = self.len();",
			"\t\twhile left_is_ok < right_is_ng {",
			"\t\t\tlet mid = (left_is_ok + right_is_ng) / 2;",
			"\t\t\tif f(&self[mid]) {",
			"\t\t\t\tleft_is_ok = mid + 1;",
			"\t\t\t} else {",
			"\t\t\t\tright_is_ng = mid;",
			"\t\t\t}",
			"\t\t}",
			"\t\tleft_is_ok",
			"\t}",
			"}",
		],
		"description": "Partition Point",
	},
	"Power Mod": {
		"scope": "rust",
		"prefix": "@pow",
		"body": [
			"fn powmod(a: usize, b: usize, m: usize) -> usize {",
			"\tif b == 0 {",
			"\t\t1",
			"\t} else if b % 2 == 0 {",
			"\t\tpowmod(a * a % m, b / 2, m)",
			"\t} else {",
			"\t\ta * powmod(a, b - 1, m) % m",
			"\t}",
			"}",
		],
		"description": "Power Mod",
	},
	"Segment Tree": {
		"scope": "rust",
		"prefix": "@segtree",
		"body": [
			"@monoid",
			"/// 遅延セグメント木",
			"/// - `(M, ⊕)`, `(Lazy, ∘)`はモノイド (可換とは限らない)。",
			"/// - 準同型性α: `apply(apply(m,l1),l2) = apply(m,l1∘l2)`",
			"/// - 準同型性β: `apply(m1⊕m2,l) = apply(m1,l)⊕apply(m2,l)`",
			"struct SegmentTree<M, Lazy>",
			"where",
			"\tM: Monoid,",
			"\tLazy: Monoid,",
			"{",
			"\tn: usize,",
			"\theight: usize,",
			"\tapply: fn(&M::Val, &Lazy::Val) -> M::Val,",
			"\tdata: Vec<M::Val>,\t// 1-based",
			"\tlazy: Vec<Lazy::Val>, // 1-based",
			"}",
			"impl<M, Lazy> SegmentTree<M, Lazy>",
			"where",
			"\tM: Monoid,",
			"\tLazy: Monoid,",
			"{",
			"\tfn new(n: usize, apply: fn(&M::Val, &Lazy::Val) -> M::Val) -> Self {",
			"\t\tlet n = n.next_power_of_two();",
			"\t\tlet height = (0..62).find(|&x| n == 1 << x).unwrap() + 1;",
			"\t\tSelf { n, height, apply, data: vec![M::id(); 2 * n], lazy: vec![Lazy::id(); 2 * n] }",
			"\t}",
			"\tfn new_with_data(data: Vec<M::Val>, apply: fn(&M::Val, &Lazy::Val) -> M::Val) -> Self {",
			"\t\tlet mut st = Self::new(data.len(), apply);",
			"\t\tfor (i, d) in data.iter().enumerate() {",
			"\t\t\tst.data[i + st.n] = d.clone();",
			"\t\t}",
			"\t\tfor i in (1..st.n).rev() {",
			"\t\t\tst.data[i] = M::op(&st.data[i << 1], &st.data[i << 1 | 1]);",
			"\t\t}",
			"\t\tst",
			"\t}",
			"\t#[inline(always)]",
			"\tfn propagate(&mut self, k: usize) {",
			"\t\tif self.lazy[k] == Lazy::id() {",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tif k < self.n {",
			"\t\t\tself.lazy[k << 1] = Lazy::op(&self.lazy[k << 1], &self.lazy[k]);",
			"\t\t\tself.lazy[k << 1 | 1] = Lazy::op(&self.lazy[k << 1 | 1], &self.lazy[k]);",
			"\t\t}",
			"\t\tself.data[k] = (self.apply)(&self.data[k], &self.lazy[k]);",
			"\t\tself.lazy[k] = Lazy::id();",
			"\t}",
			"\t#[inline(always)]",
			"\tfn propagate_all(&mut self, range: &Range<usize>) {",
			"\t\tlet l = range.start + self.n;",
			"\t\tlet r = range.end + self.n - 1;",
			"\t\tfor d in (0..self.height).rev() {",
			"\t\t\tself.propagate(l >> d);",
			"\t\t\tself.propagate(l >> d ^ 1); // XXX",
			"\t\t\tself.propagate(r >> d);",
			"\t\t\tself.propagate(r >> d ^ 1); // XXX",
			"\t\t}",
			"\t}",
			"\tfn query(&mut self, range: Range<usize>) -> M::Val {",
			"\t\tself.propagate_all(&range);",
			"\t\tlet mut l = range.start + self.n;",
			"\t\tlet mut r = range.end + self.n - 1;",
			"\t\tlet mut ans_l = M::id();",
			"\t\tlet mut ans_r = M::id();",
			"\t\twhile l <= r {",
			"\t\t\tif l & 1 == 1 {",
			"\t\t\t\tself.propagate(l);",
			"\t\t\t\tans_l = M::op(&ans_l, &self.data[l]);",
			"\t\t\t\tl += 1;",
			"\t\t\t}",
			"\t\t\tif r & 1 == 0 {",
			"\t\t\t\tself.propagate(r);",
			"\t\t\t\tans_r = M::op(&self.data[r], &ans_r);",
			"\t\t\t\tr -= 1;",
			"\t\t\t}",
			"\t\t\tl >>= 1;",
			"\t\t\tr >>= 1;",
			"\t\t}",
			"\t\tM::op(&ans_l, &ans_r)",
			"\t}",
			"\tfn update(&mut self, range: Range<usize>, val: Lazy::Val) {",
			"\t\tself.propagate_all(&range);",
			"\t\tlet mut l = range.start + self.n;",
			"\t\tlet mut r = range.end + self.n - 1;",
			"\t\twhile l <= r {",
			"\t\t\tif l & 1 == 1 {",
			"\t\t\t\tself.lazy[l] = Lazy::op(&self.lazy[l], &val);",
			"\t\t\t\tself.propagate(l);",
			"\t\t\t\tl += 1;",
			"\t\t\t}",
			"\t\t\tif r & 1 == 0 {",
			"\t\t\t\tself.lazy[r] = Lazy::op(&self.lazy[r], &val);",
			"\t\t\t\tself.propagate(r);",
			"\t\t\t\tr -= 1;",
			"\t\t\t}",
			"\t\t\tl >>= 1;",
			"\t\t\tr >>= 1;",
			"\t\t}",
			"\t\tlet l = range.start + self.n;",
			"\t\tlet r = range.end + self.n - 1;",
			"\t\tfor d in 1..self.height {",
			"\t\t\tif l & ((1 << d) - 1) != 0 {",
			"\t\t\t\tlet ll = l >> d;",
			"\t\t\t\tself.data[ll] = M::op(&self.data[ll << 1], &self.data[ll << 1 | 1]);",
			"\t\t\t}",
			"\t\t\tif (r + 1) & ((1 << d) - 1) != 0 {",
			"\t\t\t\tlet rr = r >> d;",
			"\t\t\t\tself.data[rr] = M::op(&self.data[rr << 1], &self.data[rr << 1 | 1]);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
			"impl<M, Lazy> fmt::Debug for SegmentTree<M, Lazy>",
			"where",
			"\tM: Monoid,",
			"\tM::Val: fmt::Debug,",
			"\tLazy: Monoid,",
			"\tLazy::Val: fmt::Debug,",
			"{",
			"\tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
			"\t\tlet strs = self",
			"\t\t\t.data",
			"\t\t\t.iter()",
			"\t\t\t.zip(self.lazy.iter())",
			"\t\t\t.skip(1)",
			"\t\t\t.map(|(d, l)| format!(\"{:?}/{:?},\", d, l))",
			"\t\t\t.collect_vec();",
			"\t\tlet len = strs.iter().map(|s| s.len()).max().unwrap() + 1;",
			"\t\tfor d in 0..self.height {",
			"\t\t\tfor c in strs.iter().take((1 << (d + 1)) - 1).skip((1 << d) - 1) {",
			"\t\t\t\twrite!(f, \"{:width$}\", c, width = len << (self.height - 1 - d))?;",
			"\t\t\t}",
			"\t\t\twriteln!(f)?;",
			"\t\t}",
			"\t\tOk(())",
			"\t}",
			"}",
		],
		"description": "Segment Tree",
	},
	"Tree Library": {
		"scope": "rust",
		"prefix": "@tree",
		"body": [
			"trait TreeExt {",
			"\tfn tree_diameter_nlogn(&self) -> usize;",
			"}",
			"",
			"impl<N, E, Ix> TreeExt for UnGraph<N, E, Ix>",
			"where",
			"\tIx: IndexType,",
			"{",
			"\tfn tree_diameter_nlogn(&self) -> usize {",
			"\t\tlet src = self.node_references().next().unwrap().0;",
			"\t\tlet src = *dijkstra(&self, src, None, |_| 1).iter().max_by_key(|e| e.1).unwrap().0;",
			"\t\t*dijkstra(&self, src, None, |_| 1).iter().max_by_key(|e| e.1).unwrap().1",
			"\t}",
			"}",
		],
		"description": "Tree Library",
	},
	"Union Find": {
		"scope": "rust",
		"prefix": "@uf",
		"body": [
			"struct UnionFind {",
			"\tpar: Vec<usize>,",
			"\trank: Vec<usize>,",
			"}",
			"impl UnionFind {",
			"\tfn new(n: usize) -> Self {",
			"\t\tSelf { par: vec![UINF; n], rank: vec![1; n] }",
			"\t}",
			"\tfn root(&mut self, i: usize) -> usize {",
			"\t\tif self.par[i] == UINF {",
			"\t\t\ti",
			"\t\t} else {",
			"\t\t\tself.par[i] = self.root(self.par[i]);",
			"\t\t\tself.par[i]",
			"\t\t}",
			"\t}",
			"\tfn is_same(&mut self, i: usize, j: usize) -> bool {",
			"\t\tself.root(i) == self.root(j)",
			"\t}",
			"\tfn merge(&mut self, i: usize, j: usize) -> bool {",
			"\t\tlet mut i = self.root(i);",
			"\t\tlet mut j = self.root(j);",
			"\t\tif i == j {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tif self.rank[i] < self.rank[j] {",
			"\t\t\tswap(&mut i, &mut j);",
			"\t\t}",
			"\t\tself.par[j] = i;",
			"\t\tself.rank[i] += self.rank[j];",
			"\t\ttrue",
			"\t}",
			"}",
		],
		"description": "Union Find",
	}
}