{
	"BIT": {
		"scope": "rust",
		"prefix": "@bit",
		"body": [
			"@monoid$0",
			"struct BIT<M>",
			"where",
			"\tM: Monoid,",
			"{",
			"\tnodes: Vec<M::Val>,",
			"}",
			"impl<M> BIT<M>",
			"where",
			"\tM: Monoid,",
			"{",
			"\tfn new(n: usize) -> Self {",
			"\t\tSelf { nodes: vec![M::id(); n] }",
			"\t}",
			"\tfn add(&mut self, i: usize, x: M::Val) {",
			"\t\tlet mut i = i + 1;",
			"\t\twhile i <= self.nodes.len() {",
			"\t\t\tself.nodes[i - 1] = M::op(&self.nodes[i - 1], &x);",
			"\t\t\ti += i & i.wrapping_neg();",
			"\t\t}",
			"\t}",
			"\tfn sum(&self, i: usize) -> M::Val {",
			"\t\tlet mut i = i + 1;",
			"\t\tlet mut ans = M::id();",
			"\t\twhile i > 0 {",
			"\t\t\tans = M::op(&ans, &self.nodes[i - 1]);",
			"\t\t\ti -= i & i.wrapping_neg();",
			"\t\t}",
			"\t\tans",
			"\t}",
			"}",
		],
		"description": "BIT",
	},
	"Directions": {
		"scope": "rust",
		"prefix": "@dir",
		"body": [
			"const D4: [(isize, isize); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];",
		],
		"description": "Directions",
	},
	"Factorial": {
		"scope": "rust",
		"prefix": "@fact",
		"body": [
			"let mut fact = vec![1; N + 1];",
			"for i in 0..N {",
			"\tfact[i + 1] = fact[i] * (i + 1) % MOD;",
			"}",
			"let mut inv = vec![1; N + 1];",
			"inv[N] = powmod(fact[N], MOD - 2, MOD);",
			"for i in (0..N).rev() {",
			"\tinv[i] = inv[i + 1] * (i + 1) % MOD;",
			"}",
			"",
			"fn nCk(fact: &[usize], inv: &[usize], n: usize, k: usize, m: usize) -> usize {",
			"\tif",
			"\t/*k < 0 ||*/",
			"\tk > n {",
			"\t\t0",
			"\t} else {",
			"\t\tfact[n] * inv[k] % m * inv[n - k] % m",
			"\t}",
			"}",
		],
		"description": "Factorial",
	},
	"Monoid": {
		"scope": "rust",
		"prefix": "@monoid",
		"body": [
			"trait Monoid {",
			"\ttype Val: Clone + Eq;",
			"\tfn op(a: &Self::Val, b: &Self::Val) -> Self::Val;",
			"\tfn id() -> Self::Val;",
			"}",
			"struct PlusMonoid<N>",
			"where",
			"\tN: Copy + Eq + Num,",
			"{",
			"\t_phantom: std::marker::PhantomData<N>,",
			"}",
			"impl<N> Monoid for PlusMonoid<N>",
			"where",
			"\tN: Copy + Eq + Num,",
			"{",
			"\ttype Val = N;",
			"\tfn op(a: &N, b: &N) -> N {",
			"\t\t*a + *b",
			"\t}",
			"\tfn id() -> N {",
			"\t\tN::zero()",
			"\t}",
			"}",
		],
		"description": "Monoid",
	},
	"Partition Point": {
		"scope": "rust",
		"prefix": "@part",
		"body": [
			"trait PartitionPoint {",
			"\ttype Item;",
			"\tfn partition_point<F>(&self, f: F) -> usize",
			"\twhere",
			"\t\tF: Fn(&Self::Item) -> bool;",
			"}",
			"impl<T> PartitionPoint for [T] {",
			"\ttype Item = T;",
			"\tfn partition_point<F>(&self, f: F) -> usize",
			"\twhere",
			"\t\tF: Fn(&Self::Item) -> bool,",
			"\t{",
			"\t\tlet mut left_is_ok = 0;",
			"\t\tlet mut right_is_ng = self.len();",
			"\t\twhile left_is_ok < right_is_ng {",
			"\t\t\tlet mid = (left_is_ok + right_is_ng) / 2;",
			"\t\t\tif f(&self[mid]) {",
			"\t\t\t\tleft_is_ok = mid + 1;",
			"\t\t\t} else {",
			"\t\t\t\tright_is_ng = mid;",
			"\t\t\t}",
			"\t\t}",
			"\t\tleft_is_ok",
			"\t}",
			"}",
		],
		"description": "Partition Point",
	},
	"Power Mod": {
		"scope": "rust",
		"prefix": "@pow",
		"body": [
			"fn powmod(a: usize, b: usize, m: usize) -> usize {",
			"\tif b == 0 {",
			"\t\t1",
			"\t} else if b % 2 == 0 {",
			"\t\tpowmod(a * a % m, b / 2, m)",
			"\t} else {",
			"\t\ta * powmod(a, b - 1, m) % m",
			"\t}",
			"}",
		],
		"description": "Power Mod",
	},
	"Tree Library": {
		"scope": "rust",
		"prefix": "@tree",
		"body": [
			"trait TreeExt {",
			"\tfn tree_diameter_nlogn(&self) -> usize;",
			"}",
			"",
			"impl<N, E, Ix> TreeExt for UnGraph<N, E, Ix>",
			"where",
			"\tIx: IndexType,",
			"{",
			"\tfn tree_diameter_nlogn(&self) -> usize {",
			"\t\tlet src = self.node_references().next().unwrap().0;",
			"\t\tlet src = *dijkstra(&self, src, None, |_| 1).iter().max_by_key(|e| e.1).unwrap().0;",
			"\t\t*dijkstra(&self, src, None, |_| 1).iter().max_by_key(|e| e.1).unwrap().1",
			"\t}",
			"}",
		],
		"description": "Tree Library",
	},
	"Union Find": {
		"scope": "rust",
		"prefix": "@uf",
		"body": [
			"struct UnionFind {",
			"\tpar: Vec<usize>,",
			"\trank: Vec<usize>,",
			"}",
			"impl UnionFind {",
			"\tfn new(n: usize) -> Self {",
			"\t\tSelf { par: vec![UINF; n], rank: vec![1; n] }",
			"\t}",
			"\tfn root(&mut self, i: usize) -> usize {",
			"\t\tif self.par[i] == UINF {",
			"\t\t\ti",
			"\t\t} else {",
			"\t\t\tself.par[i] = self.root(self.par[i]);",
			"\t\t\tself.par[i]",
			"\t\t}",
			"\t}",
			"\tfn is_same(&mut self, i: usize, j: usize) -> bool {",
			"\t\tself.root(i) == self.root(j)",
			"\t}",
			"\tfn merge(&mut self, i: usize, j: usize) -> bool {",
			"\t\tlet mut i = self.root(i);",
			"\t\tlet mut j = self.root(j);",
			"\t\tif i == j {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tif self.rank[i] < self.rank[j] {",
			"\t\t\tswap(&mut i, &mut j);",
			"\t\t}",
			"\t\tself.par[j] = i;",
			"\t\tself.rank[i] += self.rank[j];",
			"\t\ttrue",
			"\t}",
			"}",
		],
		"description": "Union Find",
	}
}