{
	"Directions": {
		"scope": "rust",
		"prefix": "@dir",
		"body": [
			"const D4: [(isize, isize); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];",
		],
		"description": "Directions",
	},
	"Partition Point": {
		"scope": "rust",
		"prefix": "@part",
		"body": [
			"trait PartitionPoint {",
			"\ttype Item;",
			"\tfn partition_point<F>(&self, f: F) -> usize",
			"\twhere",
			"\t\tF: Fn(&Self::Item) -> bool;",
			"}",
			"impl<T> PartitionPoint for [T] {",
			"\ttype Item = T;",
			"\tfn partition_point<F>(&self, f: F) -> usize",
			"\twhere",
			"\t\tF: Fn(&Self::Item) -> bool,",
			"\t{",
			"\t\tlet mut left_is_ok = 0;",
			"\t\tlet mut right_is_ng = self.len();",
			"\t\twhile left_is_ok < right_is_ng {",
			"\t\t\tlet mid = (left_is_ok + right_is_ng) / 2;",
			"\t\t\tif f(&self[mid]) {",
			"\t\t\t\tleft_is_ok = mid + 1;",
			"\t\t\t} else {",
			"\t\t\t\tright_is_ng = mid;",
			"\t\t\t}",
			"\t\t}",
			"\t\tleft_is_ok",
			"\t}",
			"}",
		],
		"description": "Partition Point",
	},
	"Tree Library": {
		"scope": "rust",
		"prefix": "@tree",
		"body": [
			"trait TreeExt {",
			"\tfn tree_diameter_nlogn(&self) -> usize;",
			"}",
			"",
			"impl<N, E, Ix> TreeExt for UnGraph<N, E, Ix>",
			"where",
			"\tIx: IndexType,",
			"{",
			"\tfn tree_diameter_nlogn(&self) -> usize {",
			"\t\tlet src = self.node_references().next().unwrap().0;",
			"\t\tlet src = *dijkstra(&self, src, None, |_| 1).iter().max_by_key(|e| e.1).unwrap().0;",
			"\t\t*dijkstra(&self, src, None, |_| 1).iter().max_by_key(|e| e.1).unwrap().1",
			"\t}",
			"}",
		],
		"description": "Tree Library",
	},
	"Union Find": {
		"scope": "rust",
		"prefix": "@uf",
		"body": [
			"struct UnionFind {",
			"\tpar: Vec<usize>,",
			"\trank: Vec<usize>,",
			"}",
			"impl UnionFind {",
			"\tfn new(n: usize) -> Self {",
			"\t\tSelf { par: vec![UINF; n], rank: vec![1; n] }",
			"\t}",
			"\tfn root(&mut self, i: usize) -> usize {",
			"\t\tif self.par[i] == UINF {",
			"\t\t\ti",
			"\t\t} else {",
			"\t\t\tself.par[i] = self.root(self.par[i]);",
			"\t\t\tself.par[i]",
			"\t\t}",
			"\t}",
			"\tfn is_same(&mut self, i: usize, j: usize) -> bool {",
			"\t\tself.root(i) == self.root(j)",
			"\t}",
			"\tfn merge(&mut self, i: usize, j: usize) -> bool {",
			"\t\tlet mut i = self.root(i);",
			"\t\tlet mut j = self.root(j);",
			"\t\tif i == j {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tif self.rank[i] < self.rank[j] {",
			"\t\t\tswap(&mut i, &mut j);",
			"\t\t}",
			"\t\tself.par[j] = i;",
			"\t\tself.rank[i] += self.rank[j];",
			"\t\ttrue",
			"\t}",
			"}",
		],
		"description": "Union Find",
	}
}